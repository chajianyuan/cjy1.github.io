---
title: 总结：算法
date: 2019-09-20 13:19:09
tags: 总结
category: 技术
---

<meta name="referrer" content="no-referrer"/>

# 一、二叉树

## 1、二分查找

二分查找也叫折半查找，他要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列

<!--more-->

**算法步骤**

（1）设置查找区间初值，low 为 1，high 为表长；

（2）当 low 小于等于 high 时，循环执行以下操作：

​ ·mid 取值为 low 和 high 的中间值；

​ ·将给定值 key 与中间位置记录的关键字进行比较，若相等则查找成功，返回中间位置 mid；

​ ·若不相等则利用中间位置记录将表对分成前后两个子表。如果 key 比中间位置记录的关键字小，则 high 取为 mid-1，否则 low 取为 mid+1

（3）循环结束，说明查找区间为空，则查找失败，返回 0

```
function midSearch(array, key) {
        let low = 1,
          high = array.length;
        while (low <= high) {
          let mid = (high + low) / 2;
          if (key == array[mid]) {
            return mid;
          } else if (key < array[mid]) {
            high = mid - 1;
          } else if (key > array[mid]) {
            low = mid + 1;
          }
        }
        return 0;
      }
```

## 2、二叉排序树

### 1）查找

**算法步骤**

（1）若二叉排序树为空，则查找失败，返回空指针；

（2）若二叉排序树非空，将给定值 key 与根节点的关键字进行比较；

​ ·若 key 等于根节点关键字，则查找成功，返回根节点地址；

​ ·若 key 小于根节点关键字，则递归查找左子树；

​ ·若 key 大于根节点关键字，则递归查找右子树。

```
function erchasearch(pNode, key) {
	if (!pNode || pNode.val == key) {
		return pNode;
	}
	if (key < pNode.val) {
		return erchasearch(pNode.left, key);
	} else if (key > pNode.val) {
		return erchasearch(pNode.right, key);
	}
}
```

### 2）插入

**算法步骤**

（1）若二叉排序树为空，则将待插入节点 S 做为根节点插入到空树中；

（2）若二叉排序树非空，则将 key 与根节点的值进行比较：

​ ·若 key 小于根节点的值，则把 S 插入到左子树；

​ ·若 key 大于根节点的值，则把 S 插入到右子树。

```
function erchainsert(pNode, key) {
	if (!pNode) {
 		pNode.val = key;
 		return pNode;
	}
	if (key < pNode.val) {
		return erchainsert(pNode.left, key);
	} else if (key > pNode.val) {
		return erchainsert(pNode.right, key);
	}
}
```

### 3）删除

**算法步骤**

（1）首先从二叉排序树的根节点开始查找关键字为 key 的带删除节点，如果树中不存在此节点，则不作任何操作；否则，假设被删除接地那为 p，其双亲节点为 f，PL 和 PR 分别表示其左子树和右子树 ，则只需修改其双亲节点的指针即可。

（2）若 p 节点只有左子树 PL 或者只有右子树 PR，此时只要令 PL 或 PR 直接成为其双亲节点 f 的左子树即可；

（3）若 p 节点的左子树和右子树均不为空，在删去 p 节点之前，中序遍历该二叉树得到的序列为{...CLC...QLQSLSPPRF...}，在删去 p 之后，为保持其他元素之间的相对位置不变，可以有两种处理方法：

​ ·令 p 的左子树为 f 的左子树，而 p 的右子树为 s 的右子树；

​ ·令 p 的直接前驱（或直接后继）替代 p，然后再从二叉排序树中删去它的直接前驱 （或直接后继），当以直接前驱 s 代替 p 时，由于 s 只有左子树 SL，在删去 s 之后，只要令 SL 为 s 的双亲 q 的右子树即可。

## 3、平衡二叉树

平衡二叉树或者是空树，或者是具有如下特征的二叉排序树：

（1）左子树和右子树的深度之差的绝对值不超过 1；

（2）左子树和右子树也是平衡二叉树。

# 二、排序

## 1、冒泡排序

**基本思想**

在待排序序列中选两相邻记录的数字，如果反序则交换，直到没有反序的数列为止。

**算法步骤**

（1）比较相邻的元素，如果第一个比第二个大，就交换他们两个；

（2）对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；

（3）针对所有的元素重复以上的步骤，除了最后一个；

（4）重复步骤 1-3，直到排序完成。

```
function bubbleSort(array) {
	let len = array.length;
	for (let i = 0; i < len; i++) {
		for (let j = 0; j < len - 1; j++) {
			if (array[j] > array[j + 1]) {
				let temp = array[j + 1];
				array[j + 1] = array[j];
				array[j] = temp;
			}
		}
	}
	return array;
}
```

## 2、快速排序

**算法步骤**

（1）从数列中挑出一个元素，称为基准；

（2）重新排列数列，所有元素比基准小的摆放在基准前面，所有元素比基准大的摆在基准后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；

（3）递归的把小于基准值元素的子数列和大于基准元素的子数列排序。

```
      function quickSort(array, left, right) {
        let len = array.length,
          partitionIndex,
          left = typeof left == 'number' ? left : 0,
          right = typeof right == 'number' ? right : len - 1;
        if (left < right) {
          partitionIndex = partition(array, left, right);
          quickSort(array, left, partitionIndex - 1);
          quickSort(array, partitionIndex + 1, right);
        }
        return array;
      }
      //分区操作
      function partition(array, left, right) {
        //设定基准值pivot
        let pivot = left,
          index = pivot + 1;
        for (let i = index; i <= right; i++) {
          if (array[i] < array[pivot]) {
            swap(array, i, index);
            index++;
          }
        }
      }
      //交换数据
      function swap(array, i, j) {
        let temp = array[j];
        array[i] = array[j];
        array[j] = temp;
      }
```

```
      function quickSort(arr) {
        let quick = arr => {
          sort(arr, 0, arr.length - 1);
          return arr;
        };
        let sort = (arr, left, right) => {
          if (left < right) {
            let center = findCenter(arr, left, right);
            sort(arr, 0, center - 1);
            sort(arr, center, right);
          }
        };
        let findCenter = (arr, left, right) => {
          let flag = arr[left];
          let index = left + 1;
          for (let i = index; i < arr.length; i++) {
            if (arr[i] < flag) {
              swap(arr, i, index);
              index++;
            }
          }
          swap(arr, left, index - 1);
          return index;
        };
        let swap = (arr, left, right) => {
          let mid = arr[left];
          arr[left] = arr[right];
          arr[right] = mid;
        };

        return quick(arr);
      }
```

## 3、插入排序

**主要思想**

每次将一个待排序的数字按其关键码的大小插入到一个已排好序的有序序列中，直到全部数字排好序。

**算法步骤**

（1）从第一个默认被排好序的元素开始；

（2）取出下一个元素，在已经排序的元素序列中从后向前扫描；

（3）如果已排序的元素大于取出的元素，则将其分别向后移动一位；

（4）直到找到已排序的元素中小于或等于取出的元素，将取出的元素放到他的后一位；

（5）重复步骤 2

```
      function insertionSort(array) {
        let len = array.length,
          preIndex, //从后向前扫描索引
          current; //当前元素数值
        for (let i = 1; i < len; i++) {
          preIndex = i - 1;
          current = array[i];
          while (preIndex >= 0 && array[preIndex] > current) {
            array[preIndex + 1] = array[preIndex];
            preIndex--;
          }
          array[preIndex + 1] = current;
        }
        return array;
      }
```

## 4、希尔排序

**基本思想**

先将整个待排序序列分割成若干个子序序列，在子序列分别进行直接插入排序，待整个序列基本有序时，再对整体序列进行一次插入排序。

**算法步骤**

（1）选择一个增量序列 t1,t2,...,tk，其中 ti>tj，tk=1;

（2）按增量序列个数 k，对序列进行 k 趟排序；

（3）每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序，仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度

```
      function SellSort(array) {
        let len = array.length;
        for (
          let gap = Math.floor(len / 2);
          gap > 0;
          gap = Math.floor(gap / 2)
        ) {
          //多个分组交替执行
          for (let i = gap; i < array.length; i++) {
            let j = i,
              current = array[i];
            while (j - gap >= 0 && current < array[j - gap]) {
              array[j] = array[j - gap];
              j = j - gap;
            }
            array[j] = current;
          }
        }
        return array;
      }
```

## 5、选择排序

**基本思想**

首先在待排序序列中选出最小值，存放在排序序列起始位置，然后再从剩余未排序元素中继续寻找最小元素，放到已排序序列末尾。以此类推，直到所有元素均排序完毕。

**算法步骤**

（1）初始状态：无序区为 R[1...n]，有序区为空；

（2）第 i 趟排序（i=1,2,3...n-1）开始时当前有序区和无序区分别为 R[1...i-1]和 R[i..n]，该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区中的第一个记录 R 交换，使 R[1...i]和 R[i+1...n]分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；

（3）n-1 趟结束，数组有序化了

```
      function selectionSort(array) {
        let len = array.length,
          minIndex,
          temp;
        for (let i = 0; i < len - 1; i++) {
          minIndex = i;
          for (let j = i + 1; j < len; j++) {
            if (array[j] < array[minIndex]) {
              //寻找最小的数
              minIndex = j;
            }
          }
          temp = array[i];
          array[i] = array[minIndex];
          array[minIndex] = temp;
        }
        return array;
      }
```
