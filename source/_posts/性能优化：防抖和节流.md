---
title: 性能优化：防抖和节流
date: 2020-11-01 20:27:58
tags: 性能优化
category: 技术
---

今天在写项目时遇到了一个问题，一个按钮的点击事件，因为考虑到`onClick`在移动端可能失效的问题，所以添加`onTouchEnd`方法解决这个问题，一个dom节点上添加了两个事件调用的是同一个方法，那么问题就来了，同一个事件同时被调用两次很显然是不对的，那么该如何解决呢❓

当然，就是使用**节流**方法啦，保证在一个时间段内，如果一个事件被多次调用，则只有一次生效。

既然提到了节流，我们很容易就会想到另一个名词**防抖**，下面我们来回顾下到底什么是防抖和节流呢？🤔

<!--more-->

#### 一、 节流函数

##### 1. 原理

规定在一个单位时间内只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

##### 2. 适用场景

1. 拖拽场景：规定时间内只执行一次，防止超高频次触发位置变动
2. 缩放场景：监控浏览器resize
3. 动画场景：避免短时间内多次触发动画引起性能问题

#### 3. 代码实现

```
// 手写简化版实现
// 1. 定时器实现
const throttle = (fn, delay = 500) => {
    let flag = true;
    return (...args) => {
        if(!flag) return;
        flag = false;
        setTimeout(() => {
            fn.apply(this, args);
            flag = true;
        }, delay)
    }
}

// 2. 时间戳实现
const throttle = (fn, delay = 500) => {
    let preTime = Date.now();
    return (...args) => {
        const nowTime = Date.now();
        if(nowTime - preTime >= delay) {
            preTime = Date.now();
            fn.apply(this, args);
        }
    }
}

// 3. lodash.throttle (https://www.lodashjs.com/docs/lodash.throttle)

const throttle = lodash.throttle(() => fn(), delay, options)
```

#### 二、 防抖函数

##### 1. 原理

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

##### 2. 适用场景

1. 按钮提交场景：防止多次提交按钮，只执行最后提交的一次
2. 服务端验证场景：表单验证需要服务端配合，只执行一段连续的输入事件的最后一次，还有搜索联想词功能类似

##### 3. 代码实现

```
// 手写简化版实现
// 1. 定时器实现
const debounce = (fn, delay) => {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    }
}

// 2. lodash.debounce (https://www.lodashjs.com/docs/lodash.debounce)
const debounce = lodash.debounce(() => fun(), delay, options)
```

#### 三、 节流 VS 防抖

* 防抖是延迟执行
* 节流是间隔执行，函数节流即每隔一段时间就执行一次

最后，强烈推荐[lodash库](https://www.lodashjs.com/)👍，一个很实用的JavaScript工具库！