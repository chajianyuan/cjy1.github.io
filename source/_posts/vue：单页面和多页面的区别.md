---
title: vue：单页面和多页面的区别
date: 2019-10-18 14:28:18
tags: vue
category: 技术
---

<meta name="referrer" content="no-referrer"/>

![](https://user-gold-cdn.xitu.io/2019/6/13/16b51814c9cab135?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<!--more-->

## 一、单页应用(SPA)

单页面应用就是只有一个主页面的应用，浏览器一开始就要加载所有必须的 html、css、js，所有的页面内容都包含在这个所谓的主页面中，但在写的时候，还是会分开写，对每一个功能模块组件化，单页应用跳转，就是切换相关组件，仅刷新局部资源

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## 二、多页应用(MPA)

多页应用指多个独立的页面的应用，每个页面都必须重复加载 js、css 等相关资源。多页面应用跳转，需要整页资源刷新

## 三、两者对比

| 对比项/模式 | SPA                                                                   | MPA                                                                |
| ----------- | --------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 结构        | 一个主页面+许多模块的组件                                             | 许多完整的页面                                                     |
| 体验        | 页面切换快，体验佳；当初次加载文件过多时，需要做相关的优化            | 页面切换快，网速慢的时候，体验尤其不好                             |
| 资源文件    | 组件公用的资源只需要加载一次                                          | 每个页面都要自己加载公用的资源                                     |
| 适用场景    | 对体验度和流畅度有较高要求的应用，不利于 SEO（可借助 SSR 来优化 SEO） | 适用于对 SEO 要求较高的应用                                        |
| 过渡动画    | Vue 提供了 transition 的封装组件，容易实现                            | 很难实现                                                           |
| 内容更新    | 相关组件的切换，即局部更新                                            | 整体 HTML 的切换，费钱（重复 HTTP 请求）                           |
| 路由模式    | 可以使用 hash，history                                                | 普通链接跳转                                                       |
| 数据传递    | 因为单页面，使用全局变量就好（Vuex）                                  | cookie、localStorage 等缓存方案，URL 参数，调用接口保存等          |
| 相关成本    | 前期开发成本较高，后期维护较为容易                                    | 前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要改很多地方 |

## 四、单页应用实现--前端路由

### 1、hash

早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：

```
https://www.word.com#search
```

hash 路由模式的实现主要是基于下面几个特性：

- URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；
- hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制 hash 的切换；
- 可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；
- 我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。

### 2、history

HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：

```
window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
```

history 路由模式的实现主要基于存在下面几个特性：

- pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；
- 我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；
- history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。
